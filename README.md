ВНИЗУ есть история с исправлениями 

Инструкция по запуску:
1. Установить в vs installer нагрузку c ASP.NET
2. Выбрать клонировать репозиторий при открытии vs, указать ссылку на репозиторий https://github.com/ArseniyKlevtsov/Library.
3. Установить сервер бд SQL SERVER и можно  инструмент для управления базами данных SSMS
   https://www.microsoft.com/en-us/sql-server/sql-server-downloads
   https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16

   Про бд:
   1 способ:  либо в консоли диспетчера пакетов VS прописать: Update-Database (я так не пробовал)
   2 способ: либо самому в SSMS занести бекап бд:
     сюда положить бекап C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\Backup
     в SSMS тык пкм по любой базе -> Tasks -> Restore -> Database -> указать имя LibraryDb и выбрать источник device, найти бэк ап в папке, применить
     ![image](https://github.com/user-attachments/assets/311a5c65-cde7-4481-b9e9-45f98c55489d)

   Бэк ап тут можно взять:
   https://disk.yandex.ru/d/rPWg7ovlSBOrcw
   также тут лежат картинки для "потыкать" на клиенте
   
   Есть админ в бэкапе:
   login Bob2
   password Bob2Bob2Bob2

   Если не через бэкап ставить базу, то нужно админа самому из кода выдать
   готового метода, для этого нет, я делал так: просто на 1 запуск менял метод регистрации так
   await _accountManager.AddToRoleAsync(user, "User");
   на
   await _accountManager.AddToRoleAsync(user, "Admin");
   Менять тут Library.Application.UseCases.Auth.Register в  ExecuteAsync строка 42.


13.08.2024 : 
  Требования к Web Api вроде выполнены. Возможно лишь не хватает тестов всех сервисов.
  
  Ещё вы можете заметить, что сервисов меньше чем репозиториев. 
  Я подумал не создавать очередной crud сервис, а потом добавить методы например в сервис юзера, для получения его арендованных книг

  Ещё касательно тестов. Для репозиториев я считаю достаточно 1-го класса теста (если для CRUD только брать). Т.к. все методы в базовом реп. лежат.
  А для сервисов утверждать, что хватит также 1 не совсем верно конечно, т.к. код у всех свой, но всё же это копипаста с 1-го сервиса =) (допишу на все сервисы)

"""
Требования к Web API 
  1. Реализация policy-based авторизации с использованием refresh и jwt 
  access токенов; 
  [Путь] - Library.WebApi/Extentions/ServiceRegistor.cs, method AddAuhtServices

  2. Внедрение паттерна репозиторий и Unit of Work;
  [Путь] - Library.Infrastructure/Repositories & Library.Infrastructure/UnitOfWork.cs
 
  3. Разработка middleware для глобальной обработки исключений;
  [Путь] - Library.WebApi/Middleware/GlobalExceptionHandler.cs
 
  4. Реализация пагинации; 
  [Путь] - Library.Application/Services. Во всех сервисах,где есть GetAll 
  
  5. Обеспечение покрытия репозиториев и сервисов unit-тестами; 
  [Путь] - Library.Tests
"""


23.09.2024

хорошо, но надо подправить:
 
- убери повторяющийся Id в интейрфейсе IEntity и в сущности
Не совсем понял почему Id повторяющиеся. Оставил как есть. Возможно имели ввиду, что где-то id излишние, например в книге можно вместо id этого использовать isbn, если так согласен,
были такие мысли, но не стал переделывать, показалось, что много менять пришлось бы
 
- ResponseException в Application не стоит использовать, т.к. там лежат статус коды. Код Application уровня знает про технологии API а такого быть не должно
Перенёс ResponseException в web api layer.
 
- перепиши все на UseCase
  Надеюсь верно понял, что из себя представляет UseCase. Делал так:
  1 действие (логин к примеру) - 1 класс (Login) с 1 public методом Execute + private  методы, для вынесения сложны действий
  ещё зачем-то каждому UseCase сделал интерфейс, хотя иногда они мне кажутся излишними
 
- используй исключения NotFound, BadRequest, AlreadyExists, Unauthorized
Не совсем понял, это исключения или  методы контроллеров,
если контроллеров, то я не нашёл метод AlreadyExists
а если исключения, то тоже не нашёл, написал вместо этого свои

- пагинацию производи в репозитории
  сделал классы "критерий поиска" они могут указать (а могут и не указывать) порядок сортировки, пагинацию т.д.,
  перенёс методы в репозитории для пагинации/сортировки/фильтрации всего их 3 для жанров, книг и авторов. Но в клиенет использовал лишь один, и то не все возможные поля "критерия поиска книг"
 
- убери проверки из usecase(пока у тебя это методы сервиса). Все проверки должны быть в валидаторах
Как я понял иммелись ввиду проверки полей классов DTO, или нужно было выносить даже проверку на ненайденную запись?
убрал проверки DTO, где они были, остальное оставил

 
- не сохраняй изменения в методах репозитория. Делай это через unit of work
теперь использую _unitOfWork.SaveAsync вместо сохранения в репозиториях
(возможно где-то забыл подтереть в репозиториях сейвы)

опционально:
- вместо IIncludeState и фильтров можешь использовать паттерн спецификация
Паттерн показался слишком мудрёным, оставил как IIncludeState, т.к. они тоже работают хорошо



25.09.2024

надо чутка подправить:
- нарушен dependency rule
- перенеси сервисы работы с jwt из application

  Про первый пункт:
  я посмотрел все зависимости(пакеты и проекты) во всех слоях. И не нашёл где нарушен dependency rule, потому принял первый и второй пункт за один.
  Т.к. единственное, что нашёл это два using'а как раз в jwt сервисе
  using Microsoft.Extensions.Configuration;
  using Microsoft.IdentityModel.Tokens;

  
  про второй:
  перенёс работу с jwt в инфраструктуру

  P.s. оказаось, я забыл в прошлый раз закомитить работу с заказами(арендами книг) ._.



30.09.2024

 - осталось одно замечание по тз - все еще нарушен dependency rule - application layer не должен ссылаться на infrastructure
 
 Удалил ссылку на проект Infrastructure и поправил всё, что к ней было привязано (Только UnitOfWork): 
 сделал interface IUnitOfWork и тыкнул его во всех UseCases(+JwtTokenService) вместо класса UnitOfWork.
 После потыкал проект.Всё работает
 
![image](https://github.com/user-attachments/assets/c1e4ee60-cf44-4ce4-9dae-0de3d959a08c)

